// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FILLSTATIONCONTROL_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_FILLSTATIONCONTROL_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

#include "RelayState_generated.h"

namespace flatbuffers {

struct FillStationControl;
struct FillStationControlBuilder;

struct FillStationControl FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FillStationControlBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOLENOID_1 = 4,
    VT_SOLENOID_2 = 6,
    VT_PHENUMATIC_VALVE_1 = 8,
    VT_PHENUMATIC_VALVE_2 = 10
  };
  flatbuffers::RelayState solenoid_1() const {
    return static_cast<flatbuffers::RelayState>(GetField<uint8_t>(VT_SOLENOID_1, 0));
  }
  flatbuffers::RelayState solenoid_2() const {
    return static_cast<flatbuffers::RelayState>(GetField<uint8_t>(VT_SOLENOID_2, 0));
  }
  flatbuffers::RelayState phenumatic_valve_1() const {
    return static_cast<flatbuffers::RelayState>(GetField<uint8_t>(VT_PHENUMATIC_VALVE_1, 0));
  }
  flatbuffers::RelayState phenumatic_valve_2() const {
    return static_cast<flatbuffers::RelayState>(GetField<uint8_t>(VT_PHENUMATIC_VALVE_2, 0));
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return solenoid_1();
    else if constexpr (Index == 1) return solenoid_2();
    else if constexpr (Index == 2) return phenumatic_valve_1();
    else if constexpr (Index == 3) return phenumatic_valve_2();
    else static_assert(Index != -1, "Invalid Field Index");
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SOLENOID_1, 1) &&
           VerifyField<uint8_t>(verifier, VT_SOLENOID_2, 1) &&
           VerifyField<uint8_t>(verifier, VT_PHENUMATIC_VALVE_1, 1) &&
           VerifyField<uint8_t>(verifier, VT_PHENUMATIC_VALVE_2, 1) &&
           verifier.EndTable();
  }
};

struct FillStationControlBuilder {
  typedef FillStationControl Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_solenoid_1(flatbuffers::RelayState solenoid_1) {
    fbb_.AddElement<uint8_t>(FillStationControl::VT_SOLENOID_1, static_cast<uint8_t>(solenoid_1), 0);
  }
  void add_solenoid_2(flatbuffers::RelayState solenoid_2) {
    fbb_.AddElement<uint8_t>(FillStationControl::VT_SOLENOID_2, static_cast<uint8_t>(solenoid_2), 0);
  }
  void add_phenumatic_valve_1(flatbuffers::RelayState phenumatic_valve_1) {
    fbb_.AddElement<uint8_t>(FillStationControl::VT_PHENUMATIC_VALVE_1, static_cast<uint8_t>(phenumatic_valve_1), 0);
  }
  void add_phenumatic_valve_2(flatbuffers::RelayState phenumatic_valve_2) {
    fbb_.AddElement<uint8_t>(FillStationControl::VT_PHENUMATIC_VALVE_2, static_cast<uint8_t>(phenumatic_valve_2), 0);
  }
  explicit FillStationControlBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FillStationControl> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FillStationControl>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FillStationControl> CreateFillStationControl(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::RelayState solenoid_1 = flatbuffers::RelayState::Open,
    flatbuffers::RelayState solenoid_2 = flatbuffers::RelayState::Open,
    flatbuffers::RelayState phenumatic_valve_1 = flatbuffers::RelayState::Open,
    flatbuffers::RelayState phenumatic_valve_2 = flatbuffers::RelayState::Open) {
  FillStationControlBuilder builder_(_fbb);
  builder_.add_phenumatic_valve_2(phenumatic_valve_2);
  builder_.add_phenumatic_valve_1(phenumatic_valve_1);
  builder_.add_solenoid_2(solenoid_2);
  builder_.add_solenoid_1(solenoid_1);
  return builder_.Finish();
}

struct FillStationControl::Traits {
  using type = FillStationControl;
  static auto constexpr Create = CreateFillStationControl;
  static constexpr auto name = "FillStationControl";
  static constexpr auto fully_qualified_name = "flatbuffers.FillStationControl";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "solenoid_1",
    "solenoid_2",
    "phenumatic_valve_1",
    "phenumatic_valve_2"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline const flatbuffers::FillStationControl *GetFillStationControl(const void *buf) {
  return ::flatbuffers::GetRoot<flatbuffers::FillStationControl>(buf);
}

inline const flatbuffers::FillStationControl *GetSizePrefixedFillStationControl(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<flatbuffers::FillStationControl>(buf);
}

template <bool B = false>
inline bool VerifyFillStationControlBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<flatbuffers::FillStationControl>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedFillStationControlBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<flatbuffers::FillStationControl>(nullptr);
}

inline void FinishFillStationControlBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<flatbuffers::FillStationControl> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFillStationControlBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<flatbuffers::FillStationControl> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuffers

#endif  // FLATBUFFERS_GENERATED_FILLSTATIONCONTROL_FLATBUFFERS_H_
