// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FILLSTATIONSTATUS_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_FILLSTATIONSTATUS_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

#include "RelayState_generated.h"

namespace flatbuffers {

struct FillStationStatus;
struct FillStationStatusBuilder;

struct FillStationStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FillStationStatusBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOLENOID_1 = 4,
    VT_SOLENOID_2 = 6,
    VT_PHENUMATIC_VALVE_1 = 8,
    VT_PHENUMATIC_VALVE_2 = 10,
    VT_PRESSURE_TRANSDUCER_READING = 12
  };
  flatbuffers::RelayState solenoid_1() const {
    return static_cast<flatbuffers::RelayState>(GetField<uint8_t>(VT_SOLENOID_1, 0));
  }
  flatbuffers::RelayState solenoid_2() const {
    return static_cast<flatbuffers::RelayState>(GetField<uint8_t>(VT_SOLENOID_2, 0));
  }
  flatbuffers::RelayState phenumatic_valve_1() const {
    return static_cast<flatbuffers::RelayState>(GetField<uint8_t>(VT_PHENUMATIC_VALVE_1, 0));
  }
  flatbuffers::RelayState phenumatic_valve_2() const {
    return static_cast<flatbuffers::RelayState>(GetField<uint8_t>(VT_PHENUMATIC_VALVE_2, 0));
  }
  double pressure_transducer_reading() const {
    return GetField<double>(VT_PRESSURE_TRANSDUCER_READING, 0.0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return solenoid_1();
    else if constexpr (Index == 1) return solenoid_2();
    else if constexpr (Index == 2) return phenumatic_valve_1();
    else if constexpr (Index == 3) return phenumatic_valve_2();
    else if constexpr (Index == 4) return pressure_transducer_reading();
    else static_assert(Index != -1, "Invalid Field Index");
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SOLENOID_1, 1) &&
           VerifyField<uint8_t>(verifier, VT_SOLENOID_2, 1) &&
           VerifyField<uint8_t>(verifier, VT_PHENUMATIC_VALVE_1, 1) &&
           VerifyField<uint8_t>(verifier, VT_PHENUMATIC_VALVE_2, 1) &&
           VerifyField<double>(verifier, VT_PRESSURE_TRANSDUCER_READING, 8) &&
           verifier.EndTable();
  }
};

struct FillStationStatusBuilder {
  typedef FillStationStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_solenoid_1(flatbuffers::RelayState solenoid_1) {
    fbb_.AddElement<uint8_t>(FillStationStatus::VT_SOLENOID_1, static_cast<uint8_t>(solenoid_1), 0);
  }
  void add_solenoid_2(flatbuffers::RelayState solenoid_2) {
    fbb_.AddElement<uint8_t>(FillStationStatus::VT_SOLENOID_2, static_cast<uint8_t>(solenoid_2), 0);
  }
  void add_phenumatic_valve_1(flatbuffers::RelayState phenumatic_valve_1) {
    fbb_.AddElement<uint8_t>(FillStationStatus::VT_PHENUMATIC_VALVE_1, static_cast<uint8_t>(phenumatic_valve_1), 0);
  }
  void add_phenumatic_valve_2(flatbuffers::RelayState phenumatic_valve_2) {
    fbb_.AddElement<uint8_t>(FillStationStatus::VT_PHENUMATIC_VALVE_2, static_cast<uint8_t>(phenumatic_valve_2), 0);
  }
  void add_pressure_transducer_reading(double pressure_transducer_reading) {
    fbb_.AddElement<double>(FillStationStatus::VT_PRESSURE_TRANSDUCER_READING, pressure_transducer_reading, 0.0);
  }
  explicit FillStationStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FillStationStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FillStationStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FillStationStatus> CreateFillStationStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::RelayState solenoid_1 = flatbuffers::RelayState::Open,
    flatbuffers::RelayState solenoid_2 = flatbuffers::RelayState::Open,
    flatbuffers::RelayState phenumatic_valve_1 = flatbuffers::RelayState::Open,
    flatbuffers::RelayState phenumatic_valve_2 = flatbuffers::RelayState::Open,
    double pressure_transducer_reading = 0.0) {
  FillStationStatusBuilder builder_(_fbb);
  builder_.add_pressure_transducer_reading(pressure_transducer_reading);
  builder_.add_phenumatic_valve_2(phenumatic_valve_2);
  builder_.add_phenumatic_valve_1(phenumatic_valve_1);
  builder_.add_solenoid_2(solenoid_2);
  builder_.add_solenoid_1(solenoid_1);
  return builder_.Finish();
}

struct FillStationStatus::Traits {
  using type = FillStationStatus;
  static auto constexpr Create = CreateFillStationStatus;
  static constexpr auto name = "FillStationStatus";
  static constexpr auto fully_qualified_name = "flatbuffers.FillStationStatus";
  static constexpr size_t fields_number = 5;
  static constexpr std::array<const char *, fields_number> field_names = {
    "solenoid_1",
    "solenoid_2",
    "phenumatic_valve_1",
    "phenumatic_valve_2",
    "pressure_transducer_reading"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline const flatbuffers::FillStationStatus *GetFillStationStatus(const void *buf) {
  return ::flatbuffers::GetRoot<flatbuffers::FillStationStatus>(buf);
}

inline const flatbuffers::FillStationStatus *GetSizePrefixedFillStationStatus(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<flatbuffers::FillStationStatus>(buf);
}

template <bool B = false>
inline bool VerifyFillStationStatusBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<flatbuffers::FillStationStatus>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedFillStationStatusBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<flatbuffers::FillStationStatus>(nullptr);
}

inline void FinishFillStationStatusBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<flatbuffers::FillStationStatus> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFillStationStatusBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<flatbuffers::FillStationStatus> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuffers

#endif  // FLATBUFFERS_GENERATED_FILLSTATIONSTATUS_FLATBUFFERS_H_
